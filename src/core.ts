import { IAppData } from './index';
import {
  getFiles,
  isTsProject,
  writeToFileAsync,
  getChunkName,
  tryPaths,
  hasLoadingComponent,
} from './utils';

interface IRoute {
  path: string;
  id: string;
  name: string;
  [key: string]: any;
}

interface IRoutes {
  [key: string]: IRoute;
}

interface IRouteComponents {
  [key: string]: string;
}

// 生成路由组件
export const generateRouterComponent = async (appData: IAppData) => {
  const isTs = isTsProject(appData.cwd);
  const routerMode = appData.routingMode === 'browser' ? 'BrowserRouter' : 'HashRouter';
  const fileSuffix = isTs ? 'index.tsx' : 'index.jsx';
  let content = [
    `import React, { useEffect, useState } from 'react';`,
    `import { ${routerMode} as Router, Route, Routes, Navigate } from 'react-router-dom';`,
    `import { getRoutes } from './routes';`,
    '',
    'export default function AppRouter() {',
    `  const [routes, setRoutes] = useState({});`,
    `  const [routeComponents, setRouteComponents] = useState({})`,
    '',
    '  useEffect(() => {',
    '    const { routes, routeComponents } = getRoutes();',
    '    setRoutes(routes);',
    '    setRouteComponents(routeComponents);',
    '  }, []);',
    `  const renderRoutes = () => {`,
    '    return Object.keys(routeComponents).map((key) => {',
    '      const { id, parentId, path, isLayout } = routes[key];',
    '      if (isLayout) return null;',
    '      const LayoutComponent = routeComponents[parentId];',
    '      const Component = routeComponents[id];',
    '      if (LayoutComponent) {',
    '        return (',
    '          <Route element={<LayoutComponent />} key={key}>',
    '            <Route key={id} path={path} element={<Component />} />',
    '          </Route>',
    '        )',
    '      }',
    '      return <Route key={id} path={path} element={<Component />} />',
    '    });',
    '  };',
    '',
    '  return (',
    '    <Router>',
    '      <Routes>',
    '        {renderRoutes()}',
    `        <Route path="*" element={<Navigate to="${appData.indexPath}" />} />`,
    '      </Routes>',
    '    </Router>',
    '  );',
    '}',
    '',
  ];
  await writeToFileAsync(appData.absRouterPath, fileSuffix, content.join('\n'));
};

// 生成路由文件
export const generateRoutesFile = async (appData: IAppData) => {
  const isTs = isTsProject(appData.cwd);
  const { routes, routeComponents } = getRoutes(appData);
  const componentType = isTs ? ': React.ComponentType<P>' : '';
  const lazyComponentWrapperType = isTs ? ': React.FC<P>' : '';
  const genericType = isTs ? '<P>' : '';
  const existLoading = hasLoadingComponent(appData.absLoadingPath);
  let content = [
    '// this file is generated by webpack-plugin-auto-route',
    '// do not change anytime!',
    `import React, { Suspense } from 'react';`,
    '',
    `function withLazyLoad${genericType}(LazyComponent${componentType}) {`,
    `  const lazyComponentWrapper${lazyComponentWrapperType} = (props) => (`,
    `    <Suspense fallback={<div>Loading...</div>}>`,
    `      <LazyComponent {...props} />`,
    `    </Suspense>`,
    `  );`,
    '',
    '  return lazyComponentWrapper;',
    '}',
    '',
    'export function getRoutes() {',
    `  const routes = {${renderRoutes(routes)}};`,
    '  return {',
    '    routes,',
    '    routeComponents: {',
    `      ${renderRouteComponent(routeComponents)}`,
    '    },',
    '  };',
    '}',
    '',
  ];
  if (existLoading) {
    content.splice(3, 0, `import CustomLoading from '../loading';`);
    content[7] = '    <Suspense fallback={<CustomLoading />}>';
  }
  if (isTs) {
    content.unshift('// @ts-nocheck');
  }
  const fileSuffix = isTs ? 'routes.tsx' : 'routes.jsx';
  await writeToFileAsync(appData.absRouterPath, fileSuffix, content.join('\n'));
};

// 获取路由
const getRoutes = (appData: IAppData) => {
  const files = getFiles(appData.absPagesPath, appData.excludeFolders, true);
  const layoutFiles = getFiles(appData.absLayoutsPath, appData.excludeFolders, true);
  const hasLayout = layoutFiles.length > 0;
  return fileToRoutes([...files, ...layoutFiles], appData, hasLayout);
};

// 转换成路由
const fileToRoutes = (files: string[], appData: IAppData, hasLayout: boolean) => {
  const { absPagesPath, absSrcPath, absLayoutsPath } = appData;
  return files.reduce(
    (pre, file) => {
      const isLayout = file.replace(/(\/index)?\.(j|t)sx?$/g, '') === absLayoutsPath;
      const path = isLayout
        ? '/'
        : file
            .replace(absPagesPath, '')
            .replace(/\\/g, '/')
            .replace(/(\/index)?\.(j|t)sx?$/g, '')
            .toLowerCase();
      const id = isLayout ? '@@global-layout' : path.replace(/\//g, '-').slice(1);
      const componentPath = file.replace(absSrcPath, '').replace(/\\/g, '/');
      const { requireLayout = true, ...rest } = getPageMeta(file);
      if (path !== '') {
        // 舍弃src/pages/index.(j|t)sx?;
        pre.routes[id] = {
          path,
          id,
          name: id,
          ...rest,
        };
        if (requireLayout && hasLayout && !isLayout) {
          pre.routes[id].parentId = '@@global-layout';
        }
        if (isLayout) {
          pre.routes[id].isLayout = true;
        }
        pre.routeComponents[id] = `..${componentPath}`;
      }
      return pre;
    },
    { routes: {}, routeComponents: {} } as { routes: IRoutes; routeComponents: IRouteComponents },
  );
};

// 获取页面元数据
const getPageMeta = (file: string) => {
  // NOTE: 从.meta.json文件中获取
  const filePathWithoutExt = file
    .replace(/\\/g, '/')
    .replace(/\.(j|t)sx?$/g, '')
    .toLowerCase();
  const metaFilePath = tryPaths([`${filePathWithoutExt}.meta.json`]);
  if (metaFilePath) {
    try {
      const metaInfo = require(metaFilePath);
      return metaInfo;
    } catch (error) {}
  }
  return {};
};

// 渲染路由
const renderRoutes = (routes: IRoutes): string[] => {
  return Object.keys(routes).map((id) => {
    const route = routes[id];
    let content: string[] = [];
    for (const key in route) {
      content.push(`'${key}':'${route[key]}'`);
    }
    return `'${id}':{${content.join(',')}}`;
  });
};

// 渲染路由组件
const renderRouteComponent = (routeComponents: IRouteComponents) => {
  return Object.keys(routeComponents)
    .map((key) => {
      const componentPath = routeComponents[key];
      const chunkName = getChunkName(componentPath);
      return `'${key}':withLazyLoad(React.lazy(() => import(/* webpackChunkName: "${chunkName}" */ '${componentPath}')))`;
    })
    .join(',\n');
};
