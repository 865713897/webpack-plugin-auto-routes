import fs from 'fs';
import path from 'path';
import { IAppData } from './index';
import { getFiles, isTsProject, writeToFileAsync, getChunkName, tryPaths } from './utils';

interface RouteConfig {
  id: string;
  parentId?: string;
  path: string;
  name: string;
  isLayout?: boolean;
  [key: string]: any;
}

interface PageMeta {
  requireLayout?: boolean;
  [key: string]: any;
}

type RoutesMap = Record<string, RouteConfig>;
type RouteComponentsMap = Record<string, string>;

const FILE_EXTENSION_REGEX = /(\/index)?\.(j|t)sx?$/g;
const LAYOUT_ID = '@@global-layout';
const fileCache: Record<string, string[]> = {};

// 生成路由组件
export const generateRouterComponent = async (appData: IAppData) => {
  const isTs = isTsProject(appData.cwd);
  const routerMode = appData.mode === 'browser' ? 'BrowserRouter' : 'HashRouter';
  const fileSuffix = isTs ? 'index.tsx' : 'index.jsx';
  let content = [
    `import React from 'react';`,
    `import { ${routerMode} as Router, Route, Routes, Navigate } from 'react-router-dom';`,
    `import { getRoutes } from './routes';`,
    '',
    'export default function AppRouter() {',
    `  const { routes, routeComponents } = getRoutes();`,
    '',
    `  const renderRoutes = () => {`,
    '    return Object.keys(routeComponents).map((key) => {',
    '      const { id, parentId, path, isLayout } = routes[key];',
    '      if (isLayout) return null;',
    '      const LayoutComponent = parentId ? routeComponents[parentId] : null;',
    '      const Component = routeComponents[id];',
    '      if (LayoutComponent) {',
    '        return (',
    '          <Route element={<LayoutComponent />} key={key}>',
    '            <Route key={id} path={path} element={<Component />} />',
    '          </Route>',
    '        );',
    '      }',
    '      return <Route key={id} path={path} element={<Component />} />;',
    '    });',
    '  };',
    '',
    '  return (',
    '    <Router>',
    '      <Routes>',
    '        {renderRoutes()}',
    `        <Route path="*" element={<Navigate to="${appData.indexPath}" />} />`,
    '      </Routes>',
    '    </Router>',
    '  );',
    '}',
    '',
  ];
  if (isTs) {
    content
      .splice(
        5,
        1,
        '  const { routes, routeComponents }: { routes: RoutesMap; routeComponents: RouteComponentsMap } = getRoutes();',
      )
      .splice(
        3,
        0,
        ...[
          '',
          'interface RouteConfig {',
          '  id: string;',
          '  parentId?: string;',
          '  path: string;',
          '  isLayout?: boolean;',
          '  [key: string]: any;',
          '}',
          '',
          'type RoutesMap = Record<string, RouteConfig>;',
          'type RouteComponentsMap = Record<string, React.ComponentType<any>>;',
        ],
      );
  }
  await writeToFileAsync(appData.absRouterPath, fileSuffix, content.join('\n'));
};

// 生成路由文件
export const generateRoutesFile = async (appData: IAppData, useCache: boolean) => {
  const isTs = isTsProject(appData.cwd);
  const { routes, routeComponents } = getRoutes(appData, useCache);
  let content = [
    '// this file is generated by webpack-plugin-auto-routes',
    '// do not change anytime!',
    `import React, { Suspense } from 'react';`,
    '',
    'function withLazyLoad(LazyComponent) {',
    '  const lazyComponentWrapper = (props) => (',
    '    <Suspense fallback={props.loadingComponent}>',
    '      <LazyComponent {...props} />',
    '    </Suspense>',
    '  );',
    '  return lazyComponentWrapper;',
    '}',
    '',
    'export function getRoutes() {',
    `  const routes = {${renderRoutes(routes)}};`,
    '  return {',
    '    routes,',
    '    routeComponents: {',
    `      ${renderRouteComponent(routeComponents)}`,
    '    },',
    '  };',
    '}',
    '',
  ];
  if (isTs) {
    content.unshift('// @ts-nocheck');
  }
  const fileSuffix = isTs ? 'routes.tsx' : 'routes.jsx';
  await writeToFileAsync(appData.absRouterPath, fileSuffix, content.join('\n'));
};

// 获取路由
const getRoutes = (appData: IAppData, useCache: boolean) => {
  const { absPagesPath, absLayoutsPath, ignoreFolders, ignoreFiles } = appData;
  const files = getFilesWithCache(absPagesPath, ignoreFolders, ignoreFiles, true, useCache);
  const layoutFiles = getFilesWithCache(
    absLayoutsPath,
    ignoreFolders,
    ignoreFiles,
    false,
    useCache,
  );
  const hasLayout = layoutFiles.length > 0;
  return fileToRoutes([...files, ...layoutFiles], appData, hasLayout);
};

// 获取文件
const getFilesWithCache = (
  filesPath: string,
  ignoreFolders: string[],
  ignoreFiles: string[],
  deep: boolean,
  useCache: boolean,
) => {
  const cacheKey = filesPath;
  if (useCache && fileCache[cacheKey]) {
    return fileCache[cacheKey];
  }
  const files = getFiles(filesPath, ignoreFolders, ignoreFiles, deep);
  fileCache[cacheKey] = files;
  return files;
};

function normalizePath(file: string, basePath: string): string {
  return file.replace(basePath, '').replace(/\\/g, '/');
}

// 转换成路由
const fileToRoutes = (files: string[], appData: IAppData, hasLayout: boolean) => {
  const { absPagesPath, absLayoutsPath } = appData;
  return files.reduce(
    (acc, file) => {
      const { routes, routeComponents } = acc;

      const isLayout = file.replace(FILE_EXTENSION_REGEX, '') === absLayoutsPath;
      const routePath = isLayout
        ? '/'
        : normalizePath(file, absPagesPath).replace(FILE_EXTENSION_REGEX, '').toLowerCase() || '/';

      const routeId = isLayout
        ? LAYOUT_ID
        : routePath === '/'
        ? 'index'
        : routePath.replace(/\//g, '-').slice(1);
      const componentPath = path.relative(appData.absRouterPath, file);
      const { requireLayout = true, ...rest } = getPageMeta(file);

      routes[routeId] = {
        // 约定以$开头的组件为动态路由组件，如：$id.tsx
        path: routePath.replace('$', ':'),
        id: routeId,
        name: routeId,
        ...rest,
      };

      if (requireLayout && hasLayout && !isLayout) {
        routes[routeId].parentId = LAYOUT_ID;
      }
      if (isLayout) {
        routes[routeId].isLayout = true;
      }
      routeComponents[routeId] = componentPath;
      return acc;
    },
    { routes: {}, routeComponents: {} } as {
      routes: RoutesMap;
      routeComponents: RouteComponentsMap;
    },
  );
};

// 获取页面元数据
const getPageMeta = (file: string): PageMeta => {
  // NOTE: 从.meta.json文件中获取
  const filePathWithoutExt = file
    .replace(/\\/g, '/')
    .replace(/\.(j|t)sx?$/g, '')
    .toLowerCase();
  const metaFilePath = tryPaths([`${filePathWithoutExt}.meta.json`]);
  if (metaFilePath) {
    try {
      const metaInfo = JSON.parse(fs.readFileSync(metaFilePath, 'utf-8'));
      return metaInfo;
    } catch (error) {
      return {};
    }
  }
  return {};
};

// 渲染路由
const renderRoutes = (routes: RoutesMap): string[] => {
  return Object.keys(routes).map((id) => {
    const route = routes[id];
    let content: string[] = [];
    for (const key in route) {
      let value = route[key];
      value = typeof value === 'string' ? `'${value}'` : value;
      content.push(`'${key}':${value}`);
    }
    return `'${id}':{${content.join(',')}}`;
  });
};

// 渲染路由组件
const renderRouteComponent = (routeComponents: RouteComponentsMap) => {
  return Object.keys(routeComponents)
    .map((key) => {
      const componentPath = routeComponents[key];
      const chunkName = getChunkName(componentPath);
      return `'${key}': withLazyLoad(React.lazy(() => import(/* webpackChunkName: "${chunkName}" */ '${componentPath}')))`;
    })
    .join(',\n');
};
